proc make_counter {start} {
    var n $start

    return [lambda {} { set! n [+ $n 1]; $n }]
}

let c [make_counter 10]

puts [$c]
puts [$c]

proc test_123 {num} {
    let n [+ $num 1]

    return $n
}

puts [test_123 4]

proc test_str {code} {
    let c {
        this is a test
        1234
        lcl is fun
    }

    puts "calling $code"

    return $c
}

puts [test_str "this is a test"]

puts "test_str is done"

puts testing_raw_str

proc test_2 {code} {
    let c 42

    let s [subst {
        this is a test
        this is string s
        c = $c
        code = $code
        asdf
    }]

    return $s
}

puts [test_2 thisisatest]

proc lets_see_if_floats_work {float} {
    let result [+ 3.20 $float]

    return $result
}

puts "Trying floats"
puts [lets_see_if_floats_work 3.10]

proc test_meta {code} {
    let magic_var 42
    let result [subst $code]

    return $result
}

puts [test_meta {
    this is a test $magic_var
}]


var acc 0

foreach num [list 1 2 3 4 5] {
    set! acc [+ $acc $num]
    puts "acc = $acc"
}

for {var acc2 100} {$acc2} {set! acc2 [+ $acc2 -1]} {
    puts "acc2 => $acc2"
}

var acc3 100

puts "acc3 before while loop => $acc3"

while [!= $acc3 0] {
    set! acc3 [+ $acc3 -1]

    if [== $acc3 42] {
        break
    }

    puts "acc3 => $acc3"
}


var acc4 [- 100 43]
puts "acc4 => $acc4"

var acc5 [/ 100 42.69]
puts "acc5 => $acc5"

var acc6 [% 9 2]
puts "acc6 => $acc6"

var acc7 0

proc zero? {num} {
    return [== $num 0]
}

while [< $acc7 100] {
    if [zero? [% $acc7 2]] {
        puts "acc7 => $acc7"
    }

    set! acc7 [+ $acc7 1]
}

puts "5 * 6 = [* 5 6]"

puts "and 1 0 = [and 1 0]"
puts "and 1 1 = [and 1 1]"
puts "and 0 0 = [and 0 0]"
puts "and 1 1 = [and 1 1]"
puts "or 1 0  = [or 1 0]"
puts "or 1 1  = [or 1 1]"
puts "or 0 0  = [or 0 0]"
puts "or 1 1  = [or 1 1]"
puts "not 0   = [not 0]"
puts "not 1   = [not 1]"

proc proj_euler_1 {limit} {
    var result 0
    var i 0

    for {var i 0} {< $i $limit} {set! i [+ $i 1]} {
        if [or [zero? [% $i 3]] [zero? [% $i 5]]] {
            set! result [+ $result $i]
        }
    }

    return $result
}

puts "Project Euler 1 => [proj_euler_1 1000]"

puts "=== metaprogramming"

let ex "this is 1 + 1 = [+ 1 1]"
puts $ex
let ex2 {this is 1 + 1 = [+ 1  1]}
puts $ex2
puts [subst $ex2]
let ex3 [subst {$ex}]
puts $ex3

let ts [lambda {x} {
    return [+ $x 1]
}]

puts "This is ts 2 ===> [$ts 2]"

proc make_dd {n} {
    return [lambda {x} [subst {
        + $n \$x
    }]]
}

let add11 [make_dd 11]
puts "add11 5 => [$add11 5]"

puts "Tcl-style builder pattern"

proc GET {url body} {
    var request [dict url $url]

    proc method {m} {
      set! request [put $request method $m]
    }

    proc timeout {t} {
      set! request [put $request timeout $t]
    }

    eval $body

    return $request
}

let request [GET https://www.google.com {
    method GET
    timeout 1.2
}]

puts "request => $request"

foreach key [dict keys $request] {
    puts "key => $key"
}

foreach val [dict values $request] {
    puts "value => $val"
}

puts "== namespace tests =="
namespace eval math {
    let ten 10
}

namespace eval math {
    puts $ten
} ; # expect 10

puts $math::ten ; # expect 10
puts ${math::ten} ; # expect 10

namespace eval foo {
    let eleven 11
}

puts $foo::eleven ; # expect 11
puts ${foo::eleven} ; # expect 11

namespace eval foo {
    puts $eleven ; # expect 11
}

puts "== done =="
