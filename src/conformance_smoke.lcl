# Lcl Conformance Smoke (MVP)
# This script assumes the host registered the core stdlib:
#   let, ref, var (sugar), set!, +, puts, lambda, proc, return
# Optional: ns, ns::def, get

puts "=== Lcl Conformance Smoke ==="

puts ""
puts "-- immutability & substitution --"
let x 10
puts "x=$x"                    ;# expect: x=10

puts ""
puts "-- cells (var/ref) & set! --"
var n 0                        ;# let n [ref 0]
set! n [+ $n 1]
puts "n=$n"                    ;# expect: n=1

puts ""
puts "-- quoting and subcommand substitution --"
let a 10
let s "x=$a [ + 1 2 ]"
puts $s                        ;# expect: x=10 3
let t {x=$a [ + 1 2 ]}
puts $t                        ;# expect: x=$a [ + 1 2 ]

puts ""
puts "-- user proc, return, and closures --"
proc add {a b} { return [+ $a $b] }
puts "add(20,22)=[add 20 22]"  ;# expect: add(20,22)=42

proc makeCounter {start} {
  var n $start
  return [lambda {} { set! n [+ $n 1]; $n }]
}
let c [makeCounter 10]
puts [$c]                      ;# expect: 11
puts [$c]                      ;# expect: 12

puts ""
puts "-- namespaces (optional stdlib) --"
let math [ns]
ns::def $math ten 10
puts [get math::ten]
# expect: 10

puts ""
puts "-- eval --"
# basic eval
puts [eval {+ 1 2}]            ;# expect: 3

# eval accesses outer variables (same frame)
let ev_x 42
puts [eval {+ $ev_x 1}]        ;# expect: 43

# eval defines variables in current frame
eval {let ev_y 100}
puts $ev_y                     ;# expect: 100

# eval with multiple args (joined with spaces)
let ev_cmd1 "let ev_z"
let ev_cmd2 "200"
eval $ev_cmd1 $ev_cmd2
puts $ev_z                     ;# expect: 200

# return inside eval in a proc
proc testEvalReturn {} {
  eval { return 999 }
  puts "ERROR: should not reach"
}
puts [testEvalReturn]          ;# expect: 999

puts ""
puts "-- subst --"
# variable substitution
let sub_x 42
puts [subst {x is $sub_x}]     ;# expect: x is 42

# subcommand substitution
puts [subst {sum=[+ 1 2]}]     ;# expect: sum=3

# ${name} form
let sub_foo bar
puts [subst {${sub_foo}!}]     ;# expect: bar!

# backslash escapes
puts [subst {a\tb}]            ;# expect: a	b (tab)
puts [subst {literal \$x}]     ;# expect: literal $x

# braces and quotes are literal (not grouping)
puts [subst {braces {} ok}]    ;# expect: braces {} ok

puts ""
puts "-- namespace eval --"
# define values in namespace
namespace eval myns {
  let val 100
}
puts [get myns::val]           ;# expect: 100

# define procs in namespace
namespace eval funcs {
  proc double {n} { return [+ $n $n] }
}
puts [funcs::double 7]         ;# expect: 14
namespace eval funcs {
    puts [double 8]
}                              ;# expect: 16

# nested namespace path (creates intermediates)
namespace eval outer::inner::leaf {
  let deep 42
}
puts [get outer::inner::leaf::deep]  ;# expect: 42

# multiple evals on same namespace
namespace eval ns1 { let x 1 }
namespace eval ns1 { let y 2 }
puts [get ns1::x]              ;# expect: 1
puts [get ns1::y]              ;# expect: 2

puts ""
puts "-- load --"
# load a file and call its procs
load src/conformance_lib.lcl
puts [lib_add 10 20]           ;# expect: 30
puts $LIB_CONST                ;# expect: 42

# load into namespace (import pattern)
namespace eval imported {
  load src/conformance_lib.lcl
}
puts [imported::lib_add 5 5]   ;# expect: 10
puts [get imported::LIB_CONST] ;# expect: 42

puts ""
puts "-- list operations --"
# list creation and length
let mylist [list a b c d e]
puts [llength $mylist]         ;# expect: 5

# lindex - get elements
puts [lindex $mylist 0]        ;# expect: a
puts [lindex $mylist 2]        ;# expect: c
puts [lindex $mylist 4]        ;# expect: e

# lindex - out of bounds returns empty
puts [lindex $mylist 99]       ;# expect: (empty)

# lrange - extract slice
let slice [lrange $mylist 1 3]
puts [llength $slice]          ;# expect: 3
puts [lindex $slice 0]         ;# expect: b
puts [lindex $slice 2]         ;# expect: d

# concat - concatenate lists
let list1 [list 1 2]
let list2 [list 3 4]
let combined [concat $list1 $list2]
puts [llength $combined]       ;# expect: 4
puts [lindex $combined 0]      ;# expect: 1
puts [lindex $combined 3]      ;# expect: 4

# join - join with separator
puts [join $mylist -]          ;# expect: a-b-c-d-e
puts [join $mylist {}]         ;# expect: abcde

# split - split string into list
let parts [split "hello,world,test" ","]
puts [llength $parts]          ;# expect: 3
puts [lindex $parts 0]         ;# expect: hello
puts [lindex $parts 1]         ;# expect: world
puts [lindex $parts 2]         ;# expect: test

# lappend - append to cell-bound list
var nums [list 1 2 3]
lappend nums 4 5
puts [llength $nums]           ;# expect: 5
puts [lindex $nums 3]          ;# expect: 4
puts [lindex $nums 4]          ;# expect: 5

# lset - modify element in cell-bound list
var items [list a b c]
lset items 1 B
puts [lindex $items 0]         ;# expect: a
puts [lindex $items 1]         ;# expect: B
puts [lindex $items 2]         ;# expect: c

# nested list indexing
let nested [list [list x y] [list z w]]
puts [lindex $nested 0 0]      ;# expect: x
puts [lindex $nested 0 1]      ;# expect: y
puts [lindex $nested 1 0]      ;# expect: z

puts ""
puts "-- dict operations --"
# dict create and size
let d [dict create a 1 b 2 c 3]
puts [dict size $d]            ;# expect: 3

# dict get
puts [dict get $d a]           ;# expect: 1
puts [dict get $d b]           ;# expect: 2
puts [dict get $d c]           ;# expect: 3

# dict exists
puts [dict exists $d a]        ;# expect: 1
puts [dict exists $d missing]  ;# expect: 0

# dict keys (order may vary, but count should be 3)
let ks [dict keys $d]
puts [llength $ks]             ;# expect: 3

# dict values (order may vary, but count should be 3)
let vs [dict values $d]
puts [llength $vs]             ;# expect: 3

# dict set on cell-bound dict
var md [dict create x 10]
dict set md x 20
puts [dict get $md x]          ;# expect: 20

# dict set adds new key
dict set md y 30
puts [dict get $md y]          ;# expect: 30
puts [dict size $md]           ;# expect: 2

# dict unset
dict unset md x
puts [dict size $md]           ;# expect: 1
puts [dict exists $md x]       ;# expect: 0

# empty dict
let empty [dict create]
puts [dict size $empty]        ;# expect: 0

# nested dict get with multiple keys
let nested [dict create outer [dict create inner 42]]
puts [dict get $nested outer inner]  ;# expect: 42

# dict set nested
var nd [dict create outer [dict create inner 0]]
dict set nd outer inner 99
puts [dict get $nd outer inner]      ;# expect: 99

puts ""
puts "-- if/elseif/else --"
# simple true
if 1 { puts yes }                    ;# expect: yes

# simple false (no output)
if 0 { puts ERROR }

# if-else
if 0 { puts ERROR } else { puts no } ;# expect: no

# elseif chain
if 0 {
  puts ERROR
} elseif 1 {
  puts elseif
} else {
  puts ERROR
}                                    ;# expect: elseif

# computed condition
let cond_x 5
if [+ $cond_x 0] { puts nonzero }    ;# expect: nonzero

# string truthiness
if hello { puts truthy }             ;# expect: truthy

# empty string is false
if {} { puts ERROR } else { puts empty } ;# expect: empty

# if returns last value in body
let if_result [if 1 { + 10 20 }]
puts $if_result                      ;# expect: 30

puts ""
puts "-- while --"
# basic countdown
var w_i 3
while $w_i {
  puts $w_i
  set! w_i [+ $w_i -1]
}                                    ;# expect: 3 2 1

# condition false initially (no output)
while 0 { puts ERROR }

# test re-evaluated each iteration
var w_n 2
while $w_n {
  set! w_n [+ $w_n -1]
}
puts "w_n=$w_n"                      ;# expect: w_n=0

# while returns last body value
var w_x 3
let w_result [while $w_x { set! w_x [+ $w_x -1] }]
puts "w_result=$w_result"            ;# expect: w_result=0

puts ""
puts "-- for --"
# basic for loop
for {var f_i 3} {$f_i} {set! f_i [+ $f_i -1]} {
  puts $f_i
}                                    ;# expect: 3 2 1

# condition false initially (no output)
for {var f_j 0} {$f_j} {set! f_j [+ $f_j -1]} {
  puts ERROR
}

# empty start (use existing var)
var f_k 2
for {} {$f_k} {set! f_k [+ $f_k -1]} {
  puts "k=$f_k"
}                                    ;# expect: k=2 k=1

# for returns last body value
let f_result [for {var f_m 3} {$f_m} {set! f_m [+ $f_m -1]} { $f_m }]
puts "f_result=$f_result"            ;# expect: f_result=1

puts ""
puts "-- foreach --"
# basic foreach over list
foreach fe_x [list a b c] {
  puts $fe_x
}                                    ;# expect: a b c

# foreach over list variable
let fe_items [list 1 2 3]
foreach fe_item $fe_items {
  puts $fe_item
}                                    ;# expect: 1 2 3

# empty list (no output)
foreach fe_y [list] {
  puts ERROR
}

# foreach returns last body value
let fe_result [foreach fe_z [list x y z] { $fe_z }]
puts "fe_result=$fe_result"          ;# expect: fe_result=z

# edge case: variable name equals value (tests eval fix)
let fe_edge {}
foreach fe_v [list a b fe_v] {
  let fe_edge $fe_v
}
puts "fe_edge=$fe_edge"              ;# expect: fe_edge=fe_v

puts ""
puts "=== Done ==="
