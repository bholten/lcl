# Lcl Conformance Smoke (MVP)
# This script assumes the host registered the core stdlib:
#   let, ref, var (sugar), set!, +, puts, lambda, proc, return
# Optional: ns, ns::def, get

puts "=== Lcl Conformance Smoke ==="

puts ""
puts "-- immutability & substitution --"
let x 10
puts "x=$x"                    ;# expect: x=10

puts ""
puts "-- cells (var/ref) & set! --"
var n 0                        ;# let n [ref 0]
set! n [+ $n 1]
puts "n=$n"                    ;# expect: n=1

puts ""
puts "-- quoting and subcommand substitution --"
let a 10
let s "x=$a [ + 1 2 ]"
puts $s                        ;# expect: x=10 3
let t {x=$a [ + 1 2 ]}
puts $t                        ;# expect: x=$a [ + 1 2 ]

puts ""
puts "-- user proc, return, and closures --"
proc add {a b} { return [+ $a $b] }
puts "add(20,22)=[add 20 22]"  ;# expect: add(20,22)=42

proc makeCounter {start} {
  var n $start
  return [lambda {} { set! n [+ $n 1]; $n }]
}
let c [makeCounter 10]
puts [$c]                      ;# expect: 11
puts [$c]                      ;# expect: 12

puts ""
puts "-- namespaces (optional stdlib) --"
let math [ns]
ns::def $math ten 10
puts [get math::ten]
# expect: 10

puts ""
puts "-- eval --"
# basic eval
puts [eval {+ 1 2}]            ;# expect: 3

# eval accesses outer variables (same frame)
let ev_x 42
puts [eval {+ $ev_x 1}]        ;# expect: 43

# eval defines variables in current frame
eval {let ev_y 100}
puts $ev_y                     ;# expect: 100

# eval with multiple args (joined with spaces)
let ev_cmd1 "let ev_z"
let ev_cmd2 "200"
eval $ev_cmd1 $ev_cmd2
puts $ev_z                     ;# expect: 200

# return inside eval in a proc
proc testEvalReturn {} {
  eval { return 999 }
  puts "ERROR: should not reach"
}
puts [testEvalReturn]          ;# expect: 999

puts ""
puts "-- subst --"
# variable substitution
let sub_x 42
puts [subst {x is $sub_x}]     ;# expect: x is 42

# subcommand substitution
puts [subst {sum=[+ 1 2]}]     ;# expect: sum=3

# ${name} form
let sub_foo bar
puts [subst {${sub_foo}!}]     ;# expect: bar!

# backslash escapes
puts [subst {a\tb}]            ;# expect: a	b (tab)
puts [subst {literal \$x}]     ;# expect: literal $x

# braces and quotes are literal (not grouping)
puts [subst {braces {} ok}]    ;# expect: braces {} ok

puts ""
puts "-- namespace eval --"
# define values in namespace
namespace eval myns {
  let val 100
}
puts [get myns::val]           ;# expect: 100

# define procs in namespace
namespace eval funcs {
  proc double {n} { return [+ $n $n] }
}
puts [funcs::double 7]         ;# expect: 14
namespace eval funcs {
    puts [double 8]
}                              ;# expect: 16

# nested namespace path (creates intermediates)
namespace eval outer::inner::leaf {
  let deep 42
}
puts [get outer::inner::leaf::deep]  ;# expect: 42

# multiple evals on same namespace
namespace eval ns1 { let x 1 }
namespace eval ns1 { let y 2 }
puts [get ns1::x]              ;# expect: 1
puts [get ns1::y]              ;# expect: 2

puts ""
puts "-- load --"
# load a file and call its procs
load src/conformance_lib.lcl
puts [lib_add 10 20]           ;# expect: 30
puts $LIB_CONST                ;# expect: 42

# load into namespace (import pattern)
namespace eval imported {
  load src/conformance_lib.lcl
}
puts [imported::lib_add 5 5]   ;# expect: 10
puts [get imported::LIB_CONST] ;# expect: 42

puts ""
puts "-- list operations --"
# list creation and length
let mylist [list a b c d e]
puts [llength $mylist]         ;# expect: 5

# lindex - get elements
puts [lindex $mylist 0]        ;# expect: a
puts [lindex $mylist 2]        ;# expect: c
puts [lindex $mylist 4]        ;# expect: e

# lindex - out of bounds returns empty
puts [lindex $mylist 99]       ;# expect: (empty)

# lrange - extract slice
let slice [lrange $mylist 1 3]
puts [llength $slice]          ;# expect: 3
puts [lindex $slice 0]         ;# expect: b
puts [lindex $slice 2]         ;# expect: d

# concat - concatenate lists
let list1 [list 1 2]
let list2 [list 3 4]
let combined [concat $list1 $list2]
puts [llength $combined]       ;# expect: 4
puts [lindex $combined 0]      ;# expect: 1
puts [lindex $combined 3]      ;# expect: 4

# join - join with separator
puts [join $mylist -]          ;# expect: a-b-c-d-e
puts [join $mylist {}]         ;# expect: abcde

# split - split string into list
let parts [split "hello,world,test" ","]
puts [llength $parts]          ;# expect: 3
puts [lindex $parts 0]         ;# expect: hello
puts [lindex $parts 1]         ;# expect: world
puts [lindex $parts 2]         ;# expect: test

# lappend - append to cell-bound list
var nums [list 1 2 3]
lappend nums 4 5
puts [llength $nums]           ;# expect: 5
puts [lindex $nums 3]          ;# expect: 4
puts [lindex $nums 4]          ;# expect: 5

# lset - modify element in cell-bound list
var items [list a b c]
lset items 1 B
puts [lindex $items 0]         ;# expect: a
puts [lindex $items 1]         ;# expect: B
puts [lindex $items 2]         ;# expect: c

# nested list indexing
let nested [list [list x y] [list z w]]
puts [lindex $nested 0 0]      ;# expect: x
puts [lindex $nested 0 1]      ;# expect: y
puts [lindex $nested 1 0]      ;# expect: z

puts ""
puts "-- dict operations --"
# dict create and size
let d [dict create a 1 b 2 c 3]
puts [dict size $d]            ;# expect: 3

# dict get
puts [dict get $d a]           ;# expect: 1
puts [dict get $d b]           ;# expect: 2
puts [dict get $d c]           ;# expect: 3

# dict exists
puts [dict exists $d a]        ;# expect: 1
puts [dict exists $d missing]  ;# expect: 0

# dict keys (order may vary, but count should be 3)
let ks [dict keys $d]
puts [llength $ks]             ;# expect: 3

# dict values (order may vary, but count should be 3)
let vs [dict values $d]
puts [llength $vs]             ;# expect: 3

# dict set on cell-bound dict
var md [dict create x 10]
dict set md x 20
puts [dict get $md x]          ;# expect: 20

# dict set adds new key
dict set md y 30
puts [dict get $md y]          ;# expect: 30
puts [dict size $md]           ;# expect: 2

# dict unset
dict unset md x
puts [dict size $md]           ;# expect: 1
puts [dict exists $md x]       ;# expect: 0

# empty dict
let empty [dict create]
puts [dict size $empty]        ;# expect: 0

# nested dict get with multiple keys
let nested [dict create outer [dict create inner 42]]
puts [dict get $nested outer inner]  ;# expect: 42

# dict set nested
var nd [dict create outer [dict create inner 0]]
dict set nd outer inner 99
puts [dict get $nd outer inner]      ;# expect: 99

puts ""
puts "-- if/elseif/else --"
# simple true
if 1 { puts yes }                    ;# expect: yes

# simple false (no output)
if 0 { puts ERROR }

# if-else
if 0 { puts ERROR } else { puts no } ;# expect: no

# elseif chain
if 0 {
  puts ERROR
} elseif 1 {
  puts elseif
} else {
  puts ERROR
}                                    ;# expect: elseif

# computed condition
let cond_x 5
if [+ $cond_x 0] { puts nonzero }    ;# expect: nonzero

# string truthiness
if hello { puts truthy }             ;# expect: truthy

# empty string is false
if {} { puts ERROR } else { puts empty } ;# expect: empty

# if returns last value in body
let if_result [if 1 { + 10 20 }]
puts $if_result                      ;# expect: 30

puts ""
puts "-- while --"
# basic countdown
var w_i 3
while $w_i {
  puts $w_i
  set! w_i [+ $w_i -1]
}                                    ;# expect: 3 2 1

# condition false initially (no output)
while 0 { puts ERROR }

# test re-evaluated each iteration
var w_n 2
while $w_n {
  set! w_n [+ $w_n -1]
}
puts "w_n=$w_n"                      ;# expect: w_n=0

# while returns last body value
var w_x 3
let w_result [while $w_x { set! w_x [+ $w_x -1] }]
puts "w_result=$w_result"            ;# expect: w_result=0

puts ""
puts "-- for --"
# basic for loop
for {var f_i 3} {$f_i} {set! f_i [+ $f_i -1]} {
  puts $f_i
}                                    ;# expect: 3 2 1

# condition false initially (no output)
for {var f_j 0} {$f_j} {set! f_j [+ $f_j -1]} {
  puts ERROR
}

# empty start (use existing var)
var f_k 2
for {} {$f_k} {set! f_k [+ $f_k -1]} {
  puts "k=$f_k"
}                                    ;# expect: k=2 k=1

# for returns last body value
let f_result [for {var f_m 3} {$f_m} {set! f_m [+ $f_m -1]} { $f_m }]
puts "f_result=$f_result"            ;# expect: f_result=1

puts ""
puts "-- foreach --"
# basic foreach over list
foreach fe_x [list a b c] {
  puts $fe_x
}                                    ;# expect: a b c

# foreach over list variable
let fe_items [list 1 2 3]
foreach fe_item $fe_items {
  puts $fe_item
}                                    ;# expect: 1 2 3

# empty list (no output)
foreach fe_y [list] {
  puts ERROR
}

# foreach returns last body value
let fe_result [foreach fe_z [list x y z] { $fe_z }]
puts "fe_result=$fe_result"          ;# expect: fe_result=z

# edge case: variable name equals value (tests eval fix)
let fe_edge {}
foreach fe_v [list a b fe_v] {
  let fe_edge $fe_v
}
puts "fe_edge=$fe_edge"              ;# expect: fe_edge=fe_v

puts ""
puts "-- break --"
# break in while loop
var brk_i 5
while 1 {
  puts $brk_i
  set! brk_i [+ $brk_i -1]
  if $brk_i { } else { break }
}                                    ;# expect: 5 4 3 2 1

# break in for loop (exits immediately)
for {var brk_j 1} {1} {set! brk_j [+ $brk_j 1]} {
  puts "for_brk"
  break
}                                    ;# expect: for_brk

# break in foreach (exits after first)
foreach brk_x [list a b c] {
  puts "fe_brk=$brk_x"
  break
}                                    ;# expect: fe_brk=a

puts ""
puts "-- continue --"
# continue in while loop (skip when i=2)
var cont_i 3
while $cont_i {
  let cur $cont_i
  set! cont_i [+ $cont_i -1]
  if [+ $cur -2] { } else { continue }
  puts "cw=$cur"
}                                    ;# expect: cw=3 cw=1

# continue in for loop (skip when j=2)
var cont_j 3
for {} {$cont_j} {set! cont_j [+ $cont_j -1]} {
  if [+ $cont_j -2] { } else { continue }
  puts "cf=$cont_j"
}                                    ;# expect: cf=3 cf=1

# continue in foreach (skips puts ERROR)
var cont_n 0
foreach cont_x [list a b c] {
  set! cont_n [+ $cont_n 1]
  continue
  puts ERROR
}
puts "cont_n=$cont_n"                ;# expect: cont_n=3

puts ""
puts "-- equality operators --"
# == value equality
puts [== 1 1]                        ;# expect: 1
puts [== 1 2]                        ;# expect: 0
puts [== hello hello]                ;# expect: 1
puts [== hello world]                ;# expect: 0

# Numeric string promotion (both "1" and "1.0" parse as numbers)
puts [== 1 1.0]                      ;# expect: 1 (both parse as 1.0)

# Numeric promotion (both actual floats from +)
let eq_f1 [+ 0 1]
let eq_f2 [+ 0 1.0]
puts [== $eq_f1 $eq_f2]              ;# expect: 1

# List deep equality
let eq_l1 [list 1 2 3]
let eq_l2 [list 1 2 3]
let eq_l3 [list 1 2 4]
puts [== $eq_l1 $eq_l2]              ;# expect: 1
puts [== $eq_l1 $eq_l3]              ;# expect: 0

# Dict deep equality
let eq_d1 [dict create a 1 b 2]
let eq_d2 [dict create a 1 b 2]
let eq_d3 [dict create a 1 b 3]
puts [== $eq_d1 $eq_d2]              ;# expect: 1
puts [== $eq_d1 $eq_d3]              ;# expect: 0

# != value inequality
puts [!= 1 1]                        ;# expect: 0
puts [!= 1 2]                        ;# expect: 1

# same? identity equality
let eq_x 42
puts [same? $eq_x $eq_x]             ;# expect: 1
let eq_y 42
puts [same? $eq_x $eq_y]             ;# expect: 0

# not-same? identity inequality
puts [not-same? $eq_x $eq_y]         ;# expect: 1
puts [not-same? $eq_x $eq_x]         ;# expect: 0

# cell? predicate
puts [cell? [ref 1]]                 ;# expect: 1
puts [cell? 1]                       ;# expect: 0

# same-binding? for cell bindings
var eq_p 100
var eq_q 200
puts [same-binding? eq_p eq_p]       ;# expect: 1
puts [same-binding? eq_p eq_q]       ;# expect: 0

# binding-cell returns the cell object
let eq_pcell [binding-cell eq_p]
let eq_pcell2 [binding-cell eq_p]
puts [same? $eq_pcell $eq_pcell2]    ;# expect: 1

# Proc identity via get
proc eq_f {} { 1 }
proc eq_g {} { 1 }
let eq_fp [get eq_f]
let eq_gp [get eq_g]
puts [== $eq_fp $eq_gp]              ;# expect: 0
puts [same? $eq_fp $eq_fp]           ;# expect: 1

puts ""
puts "-- equality with control flow --"

# while with == condition: count down until value equals target
var ecf_i 5
var ecf_target 2
while [!= $ecf_i $ecf_target] {
  puts "ecf_i=$ecf_i"
  set! ecf_i [+ $ecf_i -1]
}
puts "reached=$ecf_target"           ;# expect: ecf_i=5 ecf_i=4 ecf_i=3 reached=2

# for loop building list, then compare
var ecf_built [list]
for {var ecf_j 1} {[!= $ecf_j 4]} {set! ecf_j [+ $ecf_j 1]} {
  lappend ecf_built $ecf_j
}
let ecf_expected [list 1 2 3]
puts [== $ecf_built $ecf_expected]   ;# expect: 1

# foreach with == to find matching element
let ecf_haystack [list apple banana cherry date]
var ecf_found 0
foreach ecf_item $ecf_haystack {
  if [== $ecf_item cherry] {
    set! ecf_found 1
    break
  }
}
puts "found=$ecf_found"              ;# expect: found=1

# foreach with != to skip specific elements
var ecf_kept [list]
foreach ecf_x [list a skip b skip c] {
  if [!= $ecf_x skip] {
    lappend ecf_kept $ecf_x
  }
}
puts [== $ecf_kept [list a b c]]     ;# expect: 1

# while with same? to detect same binding
var ecf_obj [list 1 2 3]
var ecf_iters 0
while [same-binding? ecf_obj ecf_obj] {
  set! ecf_iters [+ $ecf_iters 1]
  if [== $ecf_iters 3] {
    break
  }
}
puts "iters=$ecf_iters"              ;# expect: iters=3

# cell? predicate in loop
var ecf_cell_count 0
let ecf_cell1 [ref 10]
let ecf_cell2 [ref 20]
let ecf_notcell 30
foreach ecf_item [list $ecf_cell1 $ecf_cell2 $ecf_notcell] {
  if [cell? $ecf_item] {
    set! ecf_cell_count [+ $ecf_cell_count 1]
  }
}
# Note: cells in lists are dereferenced when accessed with $, so count=0
puts "cell_count=$ecf_cell_count"    ;# expect: cell_count=0

# for loop comparing list elements pairwise
let ecf_a [list 1 2 3 4]
let ecf_b [list 1 2 9 4]
var ecf_diff_idx -1
for {var ecf_k 0} {[!= $ecf_k [llength $ecf_a]]} {set! ecf_k [+ $ecf_k 1]} {
  if [!= [lindex $ecf_a $ecf_k] [lindex $ecf_b $ecf_k]] {
    set! ecf_diff_idx $ecf_k
    break
  }
}
puts "diff_idx=$ecf_diff_idx"        ;# expect: diff_idx=2

# nested loops with equality checks - find common elements
let ecf_set1 [list a b c d]
let ecf_set2 [list c d e f]
var ecf_common [list]
foreach ecf_s1 $ecf_set1 {
  foreach ecf_s2 $ecf_set2 {
    if [== $ecf_s1 $ecf_s2] {
      lappend ecf_common $ecf_s1
      break
    }
  }
}
puts [== $ecf_common [list c d]]     ;# expect: 1

# while loop with dict equality
var ecf_d [dict create count 0]
while [!= [dict get $ecf_d count] 3] {
  dict set ecf_d count [+ [dict get $ecf_d count] 1]
}
puts [dict get $ecf_d count]         ;# expect: 3

# continue with equality check
var ecf_sum 0
foreach ecf_n [list 1 2 3 4 5] {
  if [== $ecf_n 3] {
    continue
  }
  set! ecf_sum [+ $ecf_sum $ecf_n]
}
puts "sum=$ecf_sum"                  ;# expect: sum=12 (1+2+4+5)

puts ""
puts "-- lexical scoping --"

# Basic closure capture: proc captures variable from definition scope
let sc_outer 100
proc sc_get_outer {} {
  $sc_outer
}
puts [sc_get_outer]                  ;# expect: 100

# Shadowing: inner binding shadows outer
let sc_shadow outer
proc sc_test_shadow {} {
  let sc_shadow inner
  $sc_shadow
}
puts [sc_test_shadow]                ;# expect: inner
puts $sc_shadow                      ;# expect: outer (unchanged)

# Closure captures the BINDING (frame slot), not the value
# Rebinding in the same frame updates what closures see
let sc_capture_val A
proc sc_capture_test {} {
  $sc_capture_val
}
let sc_capture_val B
puts [sc_capture_test]               ;# expect: B (sees rebind in same frame)

# Cell mutation through closure
var sc_counter 0
proc sc_incr {} {
  set! sc_counter [+ $sc_counter 1]
  $sc_counter
}
puts [sc_incr]                       ;# expect: 1
puts [sc_incr]                       ;# expect: 2
puts [sc_incr]                       ;# expect: 3

# Multiple closures sharing same cell
var sc_shared 0
proc sc_add {n} {
  set! sc_shared [+ $sc_shared $n]
}
proc sc_get_shared {} {
  $sc_shared
}
sc_add 10
sc_add 5
puts [sc_get_shared]                 ;# expect: 15

# Nested closures (closure returning closure)
proc sc_make_adder {x} {
  lambda {y} {
    + $x $y
  }
}
let sc_add5 [sc_make_adder 5]
let sc_add10 [sc_make_adder 10]
puts [$sc_add5 3]                    ;# expect: 8
puts [$sc_add10 3]                   ;# expect: 13

# Counter factory - each call creates independent counter
proc sc_make_counter {} {
  var n 0
  lambda {} {
    set! n [+ $n 1]
    $n
  }
}
let sc_c1 [sc_make_counter]
let sc_c2 [sc_make_counter]
puts [$sc_c1]                        ;# expect: 1
puts [$sc_c1]                        ;# expect: 2
puts [$sc_c2]                        ;# expect: 1 (independent)
puts [$sc_c1]                        ;# expect: 3

# Let rebinding in same scope
let sc_rebind first
let sc_rebind second
puts $sc_rebind                      ;# expect: second

# Proc parameter shadows outer binding
let sc_param_test outer_value
proc sc_param_shadow {sc_param_test} {
  $sc_param_test
}
puts [sc_param_shadow inner_value]   ;# expect: inner_value
puts $sc_param_test                  ;# expect: outer_value

# Nested proc definitions with shadowing
let sc_nest_val level0
proc sc_outer_proc {} {
  let sc_nest_val level1
  proc sc_inner_proc {} {
    $sc_nest_val
  }
  sc_inner_proc
}
puts [sc_outer_proc]                 ;# expect: level1

# Loop variable scoping - foreach rebinds in current frame
let sc_loop_var before
foreach sc_loop_var [list a b c] {
  # loop var is rebound each iteration
}
puts $sc_loop_var                    ;# expect: c (last iteration value)

# Loop variable scoping - for rebinds in current frame
let sc_for_i before_for
for {let sc_for_i 0} {[!= $sc_for_i 3]} {let sc_for_i [+ $sc_for_i 1]} {
  # for loop
}
puts $sc_for_i                       ;# expect: 3 (final value)

# Classic closure-in-loop capture issue
# All closures capture the SAME binding, which has final value
var sc_closures [list]
foreach sc_iter_val [list 1 2 3] {
  lappend sc_closures [lambda {} { $sc_iter_val }]
}
# All see the final value because they share the binding
puts [[lindex $sc_closures 0]]       ;# expect: 3
puts [[lindex $sc_closures 1]]       ;# expect: 3
puts [[lindex $sc_closures 2]]       ;# expect: 3

# Evil: deeply nested scope chain
let sc_deep0 d0
proc sc_deep_test {} {
  let sc_deep1 d1
  proc sc_deep_inner {} {
    let sc_deep2 d2
    proc sc_deepest {} {
      # can access all outer scopes
      list $sc_deep0 $sc_deep1 $sc_deep2
    }
    sc_deepest
  }
  sc_deep_inner
}
puts [== [sc_deep_test] [list d0 d1 d2]]  ;# expect: 1

# Evil: mutual recursion with closures
var sc_is_even_fn {}
var sc_is_odd_fn {}
set! sc_is_even_fn [lambda {n} {
  if [== $n 0] { return 1 }
  [$sc_is_odd_fn [+ $n -1]]
}]
set! sc_is_odd_fn [lambda {n} {
  if [== $n 0] { return 0 }
  [$sc_is_even_fn [+ $n -1]]
}]
puts [$sc_is_even_fn 4]              ;# expect: 1
puts [$sc_is_even_fn 3]              ;# expect: 0
puts [$sc_is_odd_fn 3]               ;# expect: 1

# Evil: closure captures closure
let sc_inner_fn [lambda {x} { + $x 1 }]
let sc_outer_fn [lambda {y} { [$sc_inner_fn $y] }]
puts [$sc_outer_fn 10]               ;# expect: 11

# Evil: self-referential through cell
var sc_factorial {}
set! sc_factorial [lambda {n} {
  if [== $n 0] { return 1 }
  + 0 [* $n [$sc_factorial [+ $n -1]]]
}]
# Note: need * operator, skip if not available
# puts [$sc_factorial 5]             ;# would expect: 120

# Verify proc doesn't pollute global scope
proc sc_local_only {} {
  let sc_very_local secret
  $sc_very_local
}
puts [sc_local_only]                 ;# expect: secret
# sc_very_local should not exist here

# Closure over parameter
proc sc_make_multiplier {factor} {
  lambda {x} {
    + 0 $factor
    # Simplified: just return factor (no * operator)
  }
}
let sc_triple [sc_make_multiplier 3]
puts [$sc_triple 10]                 ;# expect: 3

# Evil: shadowing with var vs let
let sc_shadow_type immutable
proc sc_shadow_var_let {} {
  var sc_shadow_type mutable
  set! sc_shadow_type changed
  $sc_shadow_type
}
puts [sc_shadow_var_let]             ;# expect: changed
puts $sc_shadow_type                 ;# expect: immutable

puts ""
puts "=== Done ==="
